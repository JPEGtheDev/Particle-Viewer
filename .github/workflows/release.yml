name: Automated Release

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version bump type (leave empty for auto-detection from commits)'
        required: false
        type: choice
        options:
          - ''
          - major
          - minor
          - patch
  push:
    branches:
      - master

# Prevent concurrent releases
concurrency:
  group: release
  cancel-in-progress: false

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for changelog generation
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      
      - name: Read current version from git tags
        id: current_version
        run: |
          # Get the most recent tag that matches semantic versioning pattern (vX.Y.Z)
          # List tags matching v<major>.<minor>.<patch>, sort by version, and take the latest
          RAW_VERSION=$(git tag -l "v[0-9]*.[0-9]*.[0-9]*" --sort=-v:refname | head -n 1)
          if [ -z "$RAW_VERSION" ]; then
            RAW_VERSION="v0.0.0"
          fi
          
          # Strip the 'v' prefix
          CURRENT_VERSION="${RAW_VERSION#v}"
          
          # Validate that the version matches semantic versioning pattern (X.Y.Z)
          if ! echo "$CURRENT_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Warning: Invalid version format '$CURRENT_VERSION', defaulting to 0.0.0"
            CURRENT_VERSION="0.0.0"
          fi
          
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"
      
      - name: Get commit messages since last tag
        id: commits
        run: |
          # Get last tag that matches semantic versioning pattern (vX.Y.Z) or use initial commit if no valid tags exist
          RAW_LAST_TAG=$(git describe --tags --abbrev=0 --match "v[0-9]*" 2>/dev/null || echo "")
          
          if [ -n "$RAW_LAST_TAG" ]; then
            LAST_TAG_VERSION="${RAW_LAST_TAG#v}"
            if echo "$LAST_TAG_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
              LAST_TAG="v$LAST_TAG_VERSION"
            else
              echo "Warning: Last tag '$RAW_LAST_TAG' is not a valid semantic version, using initial commit instead."
              LAST_TAG=$(git rev-list --max-parents=0 HEAD)
            fi
          else
            LAST_TAG=$(git rev-list --max-parents=0 HEAD)
          fi
          
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT
          
          # Get commit messages since last tag
          COMMITS=$(git log $LAST_TAG..HEAD --pretty=format:"%s" || git log --pretty=format:"%s")
          
          # Save commits to file for multiline handling
          echo "$COMMITS" > /tmp/commits.txt
          
          echo "Commits since last release:"
          cat /tmp/commits.txt
      
      - name: Determine version bump
        id: bump
        run: |
          # Check for manual override
          MANUAL_BUMP="${{ github.event.inputs.bump_type }}"
          if [ -n "$MANUAL_BUMP" ]; then
            echo "bump_type=$MANUAL_BUMP" >> $GITHUB_OUTPUT
            echo "Using manual bump type: $MANUAL_BUMP"
            exit 0
          fi
          
          # Auto-detect from commits
          COMMITS=$(cat /tmp/commits.txt)
          
          # Check for breaking changes (major bump)
          if echo "$COMMITS" | grep -qE "^(BREAKING CHANGE:|[a-z]+(\([^)]*\))?!:)"; then
            echo "bump_type=major" >> $GITHUB_OUTPUT
            echo "Detected BREAKING CHANGE - major version bump"
          # Check for features (minor bump)
          elif echo "$COMMITS" | grep -qE "^feat(\(.*\))?:"; then
            echo "bump_type=minor" >> $GITHUB_OUTPUT
            echo "Detected new features - minor version bump"
          # Check for fixes (patch bump)
          elif echo "$COMMITS" | grep -qE "^fix(\(.*\))?:"; then
            echo "bump_type=patch" >> $GITHUB_OUTPUT
            echo "Detected bug fixes - patch version bump"
          # Default to patch for any other commits
          else
            echo "bump_type=patch" >> $GITHUB_OUTPUT
            echo "No conventional commits detected - defaulting to patch version bump"
          fi
      
      - name: Calculate new version
        id: new_version
        run: |
          CURRENT="${{ steps.current_version.outputs.version }}"
          BUMP="${{ steps.bump.outputs.bump_type }}"
          
          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"
          
          # Increment based on bump type
          case $BUMP in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION (bump type: $BUMP)"
      
      - name: Check if version changed
        id: version_check
        run: |
          if [ "${{ steps.current_version.outputs.version }}" == "${{ steps.new_version.outputs.version }}" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "Version unchanged - skipping release"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "Version changed - proceeding with release"
          fi
      
      - name: Generate changelog entry
        if: steps.version_check.outputs.changed == 'true'
        id: changelog
        run: |
          LAST_TAG="${{ steps.commits.outputs.last_tag }}"
          NEW_VERSION="${{ steps.new_version.outputs.version }}"
          DATE=$(date +%Y-%m-%d)
          
          # Create changelog entry
          cat > /tmp/changelog_entry.md << CHANGELOG_EOF
          ## [$NEW_VERSION] - $DATE
          
          CHANGELOG_EOF
          
          # Parse commits by type
          COMMITS=$(cat /tmp/commits.txt)
          
          # Extract features
          FEATURES=$(echo "$COMMITS" | grep -E "^feat(\(.*\))?:" || true)
          if [ -n "$FEATURES" ]; then
            echo "" >> /tmp/changelog_entry.md
            echo "### Added" >> /tmp/changelog_entry.md
            while IFS= read -r line; do
              # Remove "feat:" or "feat(scope):" prefix
              MSG=$(echo "$line" | sed -E 's/^feat(\([^)]*\))?:\s*//')
              echo "- $MSG" >> /tmp/changelog_entry.md
            done <<< "$FEATURES"
          fi
          
          # Extract fixes
          FIXES=$(echo "$COMMITS" | grep -E "^fix(\(.*\))?:" || true)
          if [ -n "$FIXES" ]; then
            echo "" >> /tmp/changelog_entry.md
            echo "### Fixed" >> /tmp/changelog_entry.md
            while IFS= read -r line; do
              # Remove "fix:" or "fix(scope):" prefix
              MSG=$(echo "$line" | sed -E 's/^fix(\([^)]*\))?:\s*//')
              echo "- $MSG" >> /tmp/changelog_entry.md
            done <<< "$FIXES"
          fi
          
          # Extract breaking changes
          BREAKING=$(echo "$COMMITS" | grep -E "^(BREAKING CHANGE:|[a-z]+(\([^)]*\))?!:)" || true)
          if [ -n "$BREAKING" ]; then
            echo "" >> /tmp/changelog_entry.md
            echo "### BREAKING CHANGES" >> /tmp/changelog_entry.md
            while IFS= read -r line; do
              MSG=$(echo "$line" | sed -E 's/^[^:]*!?:\s*//')
              echo "- $MSG" >> /tmp/changelog_entry.md
            done <<< "$BREAKING"
          fi
          
          # Extract other changes (excluding breaking changes properly)
          OTHER=$(echo "$COMMITS" | grep -vE "^(feat|fix)(\(.*\))?:" | grep -vE "^BREAKING CHANGE:" | grep -vE "^[a-z]+(\([^)]*\))?!:" || true)
          if [ -n "$OTHER" ]; then
            echo "" >> /tmp/changelog_entry.md
            echo "### Changed" >> /tmp/changelog_entry.md
            while IFS= read -r line; do
              echo "- $line" >> /tmp/changelog_entry.md
            done <<< "$OTHER"
          fi
          
          echo "" >> /tmp/changelog_entry.md
          
          # Display the generated changelog
          echo "Generated changelog entry:"
          cat /tmp/changelog_entry.md
      
      - name: Create Git tag
        if: steps.version_check.outputs.changed == 'true'
        run: |
          TAG="v${{ steps.new_version.outputs.version }}"
          git tag -a "$TAG" -m "Release $TAG"
          # Push tag to remote - this must happen before creating the GitHub Release
          # because 'gh release create' expects the tag to already exist remotely
          git push origin "$TAG"
          echo "Created and pushed tag: $TAG"
      
      - name: Create GitHub Release
        if: steps.version_check.outputs.changed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="v${{ steps.new_version.outputs.version }}"
          CHANGELOG_ENTRY=$(cat /tmp/changelog_entry.md)
          
          # Create release with changelog as body
          # Note: This references the tag that was pushed in the previous step
          gh release create "$TAG" \
            --title "Release $TAG" \
            --notes "$CHANGELOG_ENTRY" \
            --target master
          
          echo "Created GitHub release: $TAG"
      
      - name: Output release info
        if: steps.version_check.outputs.changed == 'true'
        id: release_info
        run: |
          echo "version=${{ steps.new_version.outputs.version }}" >> $GITHUB_OUTPUT
          echo "tag=v${{ steps.new_version.outputs.version }}" >> $GITHUB_OUTPUT
      
      - name: Release Summary
        if: always()
        run: |
          if [ "${{ steps.version_check.outputs.changed }}" == "true" ]; then
            echo "✅ Release completed successfully!"
            echo "   - Previous version: ${{ steps.current_version.outputs.version }}"
            echo "   - New version: ${{ steps.new_version.outputs.version }}"
            echo "   - Bump type: ${{ steps.bump.outputs.bump_type }}"
            echo "   - Tag: v${{ steps.new_version.outputs.version }}"
          else
            echo "ℹ️ No version change detected - release skipped"
          fi
    
    outputs:
      version_changed: ${{ steps.version_check.outputs.changed }}
      version: ${{ steps.new_version.outputs.version }}
      tag: ${{ steps.release_info.outputs.tag }}
  
  build-flatpak:
    needs: release
    if: needs.release.outputs.version_changed == 'true'
    runs-on: ubuntu-latest
    container:
      image: bilelmoussaoui/flatpak-github-actions:freedesktop-24.08
      options: --privileged
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.release.outputs.tag }}
      
      - name: Build Flatpak
        uses: flatpak/flatpak-github-actions/flatpak-builder@v6
        with:
          bundle: particle-viewer-${{ needs.release.outputs.version }}.flatpak
          manifest-path: flatpak/org.particleviewer.ParticleViewer.yaml
          cache-key: flatpak-builder-${{ github.sha }}
      
      - name: Upload Flatpak to Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ needs.release.outputs.tag }}"
          FLATPAK_FILE="particle-viewer-${{ needs.release.outputs.version }}.flatpak"
          
          # Upload the Flatpak bundle to the release
          gh release upload "$TAG" "$FLATPAK_FILE" --clobber
          
          echo "✅ Uploaded Flatpak to release: $TAG"
