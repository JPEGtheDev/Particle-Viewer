# Particle-Viewer Context

Project-specific guidelines, conventions, and constraints for generating user stories.

---

## Project Overview

**Particle-Viewer** is a 3D visualization and playback tool for pre-computed N-Body simulation data. Think of it as a "video player" for scientific particle simulations.

**What it IS:**
- **Viewer/Renderer** - Visualizes particle positions from simulation files
- **Playback tool** - Scrubs through frames of pre-computed simulation data
- **Screenshot utility** - Captures frames for video compilation
- **3D navigation** - Camera controls to explore simulation data from different angles

**What it is NOT:**
- ❌ **NOT a physics simulator** - doesn't compute particle movements, forces, or collisions
- ❌ **NOT running simulations** - reads results from files generated by separate simulation software
- ❌ **NOT doing N-body calculations** - all physics is done externally

**Core Workflow:**
1. Load particle position data from binary files (generated by external N-Body simulator)
2. Read frame-by-frame particle positions and optional velocity data
3. Render particles as spheres in 3D space using OpenGL
4. Navigate with camera controls
5. Optionally capture screenshots for each frame

**Technical Stack:**
- **Language:** C++ (with C drivers for glad)
- **Graphics API:** OpenGL 3.0+
- **Build System:** CMake
- **Platform:** Linux (primary), Windows (supported)
- **Testing:** Transitioning to Google Test
- **CI/CD:** GitHub Actions (headless with Xvfb/Mesa)

---

## Architecture & Key Components

### Current Structure
```
src/
├── main.cpp              # Entry point, main loop
├── clutter.hpp           # Global state (NEEDS REFACTORING)
├── camera.hpp            # Camera management
├── particle.hpp          # Particle data structure
├── shader.hpp            # Shader loading/compilation
├── settingsIO.hpp        # Configuration file loading
├── osFile.hpp            # OS-specific file operations
├── glad/                 # OpenGL loader (auto-generated)
└── shaders/              # GLSL shader files
```

### Key Issues to Address
1. **Global State in clutter.hpp** – Contains `framebuffer`, `window`, `part`, `set`, `cam` as globals
2. **Tight Coupling** – Main loop directly manages all concerns
3. **No Dependency Injection** – Hard to test rendering independently
4. **Limited Test Coverage** – Unit tests exist (229+), but no visual regression tests against real GPU renders yet

---

## Story Guidelines for Particle-Viewer

### Naming Conventions

**Story Titles:**
- Use clear, action-oriented verbs: "Create", "Extract", "Add", "Refactor"
- Avoid acronyms without explanation (spell out "Framebuffer", not "FB")
- Example: ✅ "Create Framebuffer Capture Utility" vs ❌ "Add FBCapture thing"

**Components:**
- C++ classes: PascalCase (e.g., `FramebufferCapture`, `ShaderManager`)
- Methods: camelCase (e.g., `captureFrame()`, `compileShader()`)
- Files: snake_case (e.g., `framebuffer_capture.hpp`)
- Globals (deprecated): UPPER_SNAKE_CASE (e.g., `GLOBAL_FRAMEBUFFER`)

**File Paths in Stories:**
- Prefer existing repository paths and filenames (e.g., `src/settingsIO.hpp`, `src/particle.hpp`)
- Test files go in `tests/` (e.g., `tests/core/SettingsIOTests.cpp` or `tests/core/ParticleTests.cpp`)
- If the story describes a refactor introducing new structure, **mark target-state paths explicitly**, for example: `target-state: src/graphics/framebuffer_capture.hpp` or `target-state: tests/graphics/FramebufferCaptureTests.cpp`
- Shaders go in `src/shaders/`

---

## Validation Rules for Particle-Viewer Stories

### Testing Requirements

All stories **must** address testing:

- **Unit Tests:** GoogleTest for isolated components  
  Location: `tests/[component]/[FeatureTests.cpp]`
  Coverage target: ≥85% for new code

- **Integration Tests:** Verify components work together  
  May require headless OpenGL context (`xvfb-run` in CI)

- **Visual Regression Tests:** For rendering changes  
  Capture framebuffer → compare against baseline images

### CI/CD Compliance

Stories involving rendering **must** be compatible with:
- Mesa drivers (software OpenGL)
- Xvfb (virtual display server)
- GitHub Actions Ubuntu runners
- No GPU acceleration assumed in CI

**Example Acceptance Criterion:**  
✅ "Integration tested on GitHub Actions (Xvfb, Mesa drivers)"

### Code Quality Standards

Stories should reference:
- **Linting:** Project uses clang-tidy (if configured)
- **Formatting:** clang-format with project style
- **Static Analysis:** Address any new warnings
- **Memory Safety:** Valgrind clean for C code involving malloc

### Dependencies & Layering

The project should follow a layering approach (target state):

```
┌────────────────────────┐
│   Main Application     │ (main.cpp - orchestrator)
├────────────────────────┤
│   Input/UI Layer       │ (keyboard, mouse, file dialogs, playback controls)
├────────────────────────┤
│   Data Layer           │ (binary file I/O, particle data, settings, frame management)
├────────────────────────┤
│   Rendering Layer      │ (shaders, framebuffer, camera, GL buffers, screenshots)
├────────────────────────┤
│   Graphics API Layer   │ (OpenGL, glad)
└────────────────────────┘
```

**Key: This is a VIEWER, not a simulator.**
- Data Layer reads pre-computed positions from binary files
- There is NO physics simulation, NO force calculations, NO N-body computation
- Frame advancement is playback (like a video player), not simulation stepping
- Particle positions/velocities come from external simulation tools

**Story Rule:** New stories should move code **toward** this architecture, not introduce cross-layer dependencies.

---

## Visual Regression Testing Stories

### Implemented Infrastructure

The visual regression testing infrastructure is now in place:

- **PixelComparator** (`src/testing/PixelComparator.hpp`) — RGBA image comparison with configurable tolerance
- **ImageConverter** (`src/ImageConverter.hpp`) — PPM ↔ PNG format conversion using stb_image_write
- **VisualTestHelpers** (`tests/visual-regression/VisualTestHelpers.hpp`) — Test fixture, EXPECT_VISUAL_MATCH macros, helper functions
- **GitHub Actions Workflow** (`.github/workflows/visual-regression.yml`) — CI with Xvfb, artifact upload, PR comments

The `Image` struct is the base type for all image operations. Use it for creating, comparing, and converting test images.

### Particle-Viewer-Specific Requirements

Stories involving visual regression testing should:

1. **Use the Image struct** as the base type for all image data (defined in `PixelComparator.hpp`)

2. **Follow AAA Pattern** in tests:
   - Do not combine Arrange and Act into `// Arrange & Act`
   - Omit `// Arrange` if no setup is needed
   - Put expected values as named variables in Arrange

3. **Support Headless Mode**  
   - No display required (works with Xvfb on CI)
   - Must not assume real GPU

4. **Baseline Image Management**  
   - Include logic for updating baselines when rendering intentionally changes
   - Store baseline images in `tests/visual-regression/baselines/`

5. **Cross-Platform Compatibility**  
   - Mesa on Linux ✅
   - (Windows support TBD)

6. **CI Integration**  
   - Artifacts (diff images) uploaded to GitHub Actions
   - Comment on PR with visual diff summary
   - See `.github/workflows/visual-regression.yml`

### Example Visual Regression Story

**Title:** "Integrate Visual Regression Tests into GitHub Actions"

**Acceptance Criteria:**
- [x] Tests run headless with `xvfb-run` on Ubuntu runner
- [x] Test failure produces diff image (current vs baseline)
- [x] GitHub Action publishes diff as artifact
- [x] PR comment auto-posts screenshot comparison
- [ ] Baseline images committed to `tests/visual-regression/baselines/`

**Definition of Done:**
- [x] GitHub Actions workflow written and tested in branch
- [x] Documentation in `docs/testing/visual-regression.md`
- [x] Example tests and corresponding helpers
- [ ] All CI checks passing

---

## Refactoring Story Guidelines

### Addressing Technical Debt

Current refactoring priorities:

1. **Global State Elimination** (Priority: High)
   - Extract global variables from `clutter.hpp`
   - Create manager classes for framebuffer, window, particle data, camera, playback
   - Use dependency injection

2. **Main Loop Simplification** (Priority: Medium)
   - Separate concerns: input handling, data loading, rendering
   - Main loop should orchestrate: poll input → load frame data → render → swap
   - No `GameEngine` - this is a viewer, not a game

3. **SettingsIO Decomposition** (Priority: Medium)
   - Currently mixes: file I/O, playback state, simulation params, file dialogs
   - Split into: FileLoader (I/O), PlaybackState (frame/play/record), ViewerSettings (config)

4. **Shader Management** (Priority: Medium)
   - Centralize shader loading/compilation
   - Support shader reloading for development (hot-reload)

5. **Test Infrastructure** (Priority: High)
   - Add GoogleTest framework
   - Create reusable test fixtures for OpenGL context setup
   - Visual regression testing for rendering verification

### Refactoring Story Template for Particle-Viewer

```markdown
**Title:** Extract [Class Name] from [Current Location]

**Type:** Refactor  
**Component:** [e.g., Graphics, Simulation, Utilities]  
**Related Technical Debt:** [Global state issue, tight coupling, etc.]

---

### User Story

**As a** developer  
**I want to** move [code] into a [ClassName] with clear responsibilities  
**So that** [testing/maintenance/reuse] becomes easier

---

### Acceptance Criteria

- [ ] New class in `src/[component]/[ClassName].hpp`
- [ ] Old code removed from `clutter.hpp` (no dead code)
- [ ] All existing tests pass without modification
- [ ] New class has ≥85% test coverage in `tests/[component]/[ClassNameTests.cpp]`
- [ ] Constructor + public methods clearly documented with comments
- [ ] No hidden global dependencies – all state passed in or dependency-injected

---

### Definition of Done

- [ ] Code review approved
- [ ] All CI tests pass
- [ ] Cyclomatic complexity reported and acceptable
- [ ] No performance regression vs. original code
```

---

## Epic & Large Story Breakdown Guidelines

If a story is too large (M or L), it should be broken into subtasks following this pattern:

```
[Epic]: Visual Regression Testing Infrastructure
├── Subtask 1: Create Framebuffer Capture Utility (S)
├── Subtask 2: Implement Pixel Comparator (S)
├── Subtask 3: Automate Image Conversion (S)
├── Subtask 4: Integrate with GoogleTest (M)
├── Subtask 5: GitHub Actions Workflow (M)
└── Subtask 6: Auto-comment Visual Diffs on PRs (M)
```

Each subtask should be independently completable and mergeable.

---

## Definition of Done Checklist

All Particle-Viewer stories should confirm:

### Code Quality
- [ ] Code compiles with no warnings
- [ ] Passes `clang-tidy` (or equivalent linter)
- [ ] Follows project code style (clang-format configured)
- [ ] No dead code left behind

### Testing
- [ ] Unit tests pass locally and on CI
- [ ] Test coverage ≥85% for new code
- [ ] Headless testing verified (Xvfb on GitHub Actions)

### Documentation
- [ ] Public API has comments/docstrings
- [ ] New build flags documented (if any)
- [ ] README.md updated (if user-facing)

### CI/CD Integration
- [ ] All GitHub Actions checks pass
- [ ] No new compiler/linter warnings
- [ ] Artifact uploads verified (if applicable)

### Review & Merge
- [ ] Code review approved by at least one maintainer
- [ ] All comments resolved
- [ ] Commit history clean (no WIP commits)
- [ ] Ready to merge to `main` branch

---

## Quick Reference: Story Size Estimates

For **Particle-Viewer** stories, use these as rough guides:

### Small (S) – 3–5 hours
- Extract single function into class method
- Write pixel comparator for 2 image formats
- Add one shader utility function
- Fix isolated bug

### Medium (M) – 1–2 days
- Implement a new manager class with tests
- Build framebuffer capture with tests
- Refactor module with ≥85% existing test coverage
- Write GitHub Actions workflow

### Large (L) – 2–3 days
- Requires coordination between multiple files
- Breaking into smaller stories recommended
- Example: "Eliminate all global state from viewer"

### Spike (Exploratory) – 1 day max
- Investigate framework/library suitability
- Proof-of-concept (throw-away code)
- Research + recommendation document

---

## Communication Tips

### In Story Body
- Be specific: "Capture 1920×1080 RGBA framebuffer as PPM" vs "Make capture work"
- Link to related issues: "Enables #123: Visual Regression Testing"
- Reference architecture: "Moves window management out of global scope"

### In Acceptance Criteria
- Include metrics: "≤16ms per capture" vs "fast"
- List affected files: `src/FramebufferCapture.hpp` (or target-state: `src/graphics/framebuffer_capture.hpp`) 
- Call out edge cases: "Handles framebuffer size changes mid-capture"

### In Definition of Done
- Explicit testing requirements: "Valgrind reports zero leaks"
- Explicit CI requirements: "Pass on Mesa + Xvfb"
- Explicit review requirements: "Approved by lead graphics developer"
